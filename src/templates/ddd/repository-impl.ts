import type { GeneratorConfig } from '../../types/index.js';

/**
 * Generates Infrastructure Repository Implementation with mock data
 */
export function generateRepositoryImpl(config: GeneratorConfig): string {
  const { entityName, moduleName, columns } = config;

  // Generate mock data fields
  const mockFields = columns.map(c => {
    if (c.key === 'createdAt') {
      return `      createdAt: new Date().toISOString(),`;
    }
    if (c.key === 'status') {
      return `      status: Math.random() > 0.5 ? 'Active' : 'Inactive',`;
    }
    if (c.key === 'name') {
      return `      name: \`${entityName} \${i + 1}\`,`;
    }
    if (c.type === 'number') {
      return `      ${c.key}: (i + 1) * 100,`;
    }
    if (c.type === 'boolean') {
      return `      ${c.key}: Math.random() > 0.5,`;
    }
    if (c.type === 'date') {
      return `      ${c.key}: new Date().toISOString(),`;
    }
    return `      ${c.key}: \`${c.label} \${i + 1}\`,`;
  }).join('\n');

  return `import { ${entityName}, Create${entityName}DTO, Update${entityName}DTO } from '../../domain/entities/${moduleName}.entity';
import { I${entityName}Repository } from '../../domain/repositories/${moduleName}.repository.interface';

/**
 * Repository Implementation: ${entityName}
 * Generated by shadcn-page-gen
 *
 * This is a mock implementation with in-memory data.
 * Replace with your actual API calls.
 */
export class ${entityName}Repository implements I${entityName}Repository {
  // Mock data - replace with real API calls
  private items: ${entityName}[] = Array.from({ length: 10 }).map((_, i) => ({
    id: (i + 1).toString(),
${mockFields}
    updatedAt: new Date(),
  })) as unknown as ${entityName}[];

  async findAll(params?: any): Promise<${entityName}[]> {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 500));

    // TODO: Implement sorting, filtering, pagination
    // const { sortBy, order, page, limit } = params || {};

    return [...this.items];
  }

  async findById(id: string): Promise<${entityName} | null> {
    await new Promise(resolve => setTimeout(resolve, 300));
    const item = this.items.find(i => i.id === id);
    return item || null;
  }

  async create(data: Create${entityName}DTO): Promise<${entityName}> {
    await new Promise(resolve => setTimeout(resolve, 500));

    const newItem: ${entityName} = {
      id: Date.now().toString(),
      ...data,
      updatedAt: new Date(),
      ${columns.some(c => c.key === 'createdAt') ? 'createdAt: new Date().toISOString(),' : ''}
    } as unknown as ${entityName};

    this.items.push(newItem);
    return newItem;
  }

  async update(data: Update${entityName}DTO): Promise<${entityName}> {
    await new Promise(resolve => setTimeout(resolve, 500));

    const index = this.items.findIndex(i => i.id === data.id);
    if (index === -1) {
      throw new Error(\`${entityName} with id \${data.id} not found\`);
    }

    this.items[index] = {
      ...this.items[index],
      ...data,
      updatedAt: new Date(),
    } as ${entityName};

    return this.items[index];
  }

  async delete(id: string): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 500));

    const index = this.items.findIndex(i => i.id === id);
    if (index === -1) {
      throw new Error(\`${entityName} with id \${id} not found\`);
    }

    this.items.splice(index, 1);
  }
}
`;
}
